## Пример организации структуры приложения

### Структра

Приложение построено по архитектуре MVVM (можно выбрать любую другою, общие рекомендации остануться актуальны).
Model - View - ViewModel: шаблон проектирования, позволяет разделить приложение на несколько частей по их назанчению. 
Model - работа с данными, запросы, основная логика приложения
View - представление, не только xml, но и классы которые отвечают за отображение
ViewModel - объединяет предыдущие два слоя

Классы нужно группировать по пакетам в зависимости от их назначения. В пакете можно дополнительно группировать по фичам (к примеру в пакете ui можно ещё добавить отдельный пакет для каждого экрана). Такая группировка поможет в будущем легко найти нужные классы.
В общем классы могут быть разбиты по слоям (работа с сетью, данные, представление), или по фичам в отдельные модули и уже в каждом модуле разделены ещё дополнительно по слоям.
Примерная структура приложения может быть такой:

- common - классы общие для разных частей приложения, например Resource скорее всего будет в большинстве частей приложения, так как он определяет общий формат ответа, хранит статус ответа (успех или ошибка) и данные.
- data - пакет содержит классы которые относятся к слою данных. В этом пакете классы отвечают за получение данных
-- dto - (Data transfer object) модели описывающие структуры данных, к примеру с сервра приходит json и класс CoursesResponse описывает структуру корневого элемента json&
-- repository - классы методы которых предоставляют данные, тут не важно откуда данные приходят сеть, файл база данных и т.д. Каким образом данные будут получены это уже детали реализации и их можно вынести в отдельный пакет или модуль.
- network - классы для работы с сетью, он не находиться в data так как является уже способом получения данных, одним из возможных вариантов (к примеру возможно получение из базы данных или файла)
- ui - классы связанные с отображением информации. Активити, фрагменты, мапперы и фабрики которые создают данные для отображения.

### Код

В этом примере не используется DI библиотека, но даже в таком случае нужно избегать создание объектов внутри класса. Все необходимые зависимости можно передать через конструктор. Если необходимо то лучше создать дополнительные классы которые будут предоставлять зависимости в классы, в будущем это с меньшими усилиями позволит внедрить DI библиотеку и уже сейчас облегчит тестирование.

В этом примере это RetrofitBuilder - отвечает за создание сервиса для работы с апи, и ViewModelFactory создает ViewModel с нужными параметрами. Такой подход позволил удобно протестировать как репозиторий который зависит от апи сервиса так и ViewModel.

Для каждого экрана у которого есть сложные представления лучше создавать отдельный пакет в котором будут классы необходимые для этих представлений. Если такие классы могут использоваться в нескольких экранах (являются переиспользуемыми) можно вынести их в отдельный пакет в нутри ui.

Также в ui могут находится модели которые описывают структуру данных для отображения, как пример CourseGroup которая включает только заголовок и колличество курсов. Такие модели получают с помощью маппера который представляет класс с методами принимающими на вход объект (к примеру ответ сервера) и пребразующими его в структуру удобную для отображения.

Не стоит создавать лишних интерфейсов, если нужна только одна реализация, в случае если потребуется второй вариант интерфейс всегда можно добавить.

Классы лучше распологать в отдельных файлах, стоит избегать внутренних классов без необходимости. Предпочтительно имень много файлов с небольшим объемом кода, чем один огромный файл, в дальнейшем это облегчит поиск нужного места в коде и понимае как работает код. 
К примеру в пакете widget для каждого класса используется отдельный файл. 

Если View имеет много настроек из кода, можно создать отдельный класс внутри которого произвести все манипуляции для настройки (пример CourseGroupsView), такой подход облегчит чтение кода в дальнейшем.

Строковые ресурсы нужно выносить в файл strings даже, если не предпологается переводов - в дальнейшем это поможет добавить переводы и упростит написание тестов для классов использующих эти строки.

### Тесты

В тестах желательно сохранить точно такую структуру пакетов, так всегда будет удобно быстро найти нужный тест.
Отдельно в тестах стоит создать файлы с тестовыми данными. Таких файлов может быть несколько или один зависит только от объема необходимых тестовых данных.
Unit тестами нужно покрыть (как минимум):
- десерриализацию json ответов сервера в модели, чтобы убедиться в корректном составлении моделей данных
- репозитории
- мапперы и фабрики
- viewModel, презентеры, интеракторы
- классы утилит отвечающих за вычесления, форматирование
Такой набор unit тестов позволит быстро проверять внесенные измениея. View возможно не покрывать тестами если в них нет логики, вся логика должна быть вынесена в ViewModel или презентеры.
